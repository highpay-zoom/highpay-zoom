<!DOCTYPE html>
<!-- saved from url=(0045)http://www.cnblogs.com/jietang/p/5615681.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园</title>
<link type="text/css" rel="stylesheet" href="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/bundle-CodingLife.css">
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/bundle-CodingLife-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/jietang/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/jietang/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/jietang/wlwmanifest.xml">
<script type="text/javascript" src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/encoder.js.下载"></script><script src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/jquery.js.下载" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'jietang', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/jietang/"><img id="blogLogo" src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/jietang/">Tang Jie's Blog</a></h1>
<h2>茗外清风移月影，壶边夜静听松声</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/jietang/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/Newland">联系</a></li>
<li>
<!----></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 10&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 69</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/jietang/p/5615681.html">谈谈如何使用Netty开发实现高性能的RPC服务器</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><p>　　RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络，从远程计算机程序上请求服务，而不必了解底层网络技术的协议。说的再直白一点，就是客户端在不必知道调用细节的前提之下，调用远程计算机上运行的某个对象，使用起来就像调用本地的对象一样。目前典型的RPC实现框架有：Thrift（facebook开源）、Dubbo（alibaba开源）等等。RPC框架针对网络协议、网络I/O模型的封装是透明的，对于调用的客户端而言，它就认为自己在调用本地的一个对象。至于传输层上，运用的是TCP协议、UDP协议、亦或是HTTP协议，一概不关心。从网络I/O模型上来看，是基于select、poll、epoll方式、还是IOCP（I/O Completion Port）方式承载实现的，对于调用者而言也不用关心。</p>
<p>　　目前，主流的RPC框架都支持跨语言调用，即有所谓的IDL（接口定义语言），其实，这个并不是RPC所必须要求的。如果你的RPC框架没有跨语言的要求，IDL就可以不用包括了。</p>
<p>　　最后，值得一提的是，衡量一个RPC框架性能的好坏与否，RPC的网络I/O模型的选择，至关重要。在此基础上，设计出来的RPC服务器，可以考虑支持阻塞式同步IO、非阻塞式同步IO、当然还有所谓的多路复用IO模型、异步IO模型。支持不同的网络IO模型，在高并发的状态下，处理性能上会有很大的差别。还有一个衡量的标准，就是选择的传输协议。是基于TCP协议、还是HTTP协议、还是UDP协议？对性能也有一定的影响。但是从我目前了解的情况来看，大多数RPC开源实现框架都是基于TCP、或者HTTP的，目测没有采用UDP协议做为主要的传输协议的。</p>
<p>　　明白了RPC的使用原理和性能要求。现在，我们能不能撇开那些RPC开源框架，自己动手开发一个高性能的RPC服务器呢？我想，还是可以的。现在本人就使用Java，基于Netty，开发实现一个高性能的RPC服务器。</p>
<p>　　如何实现、基于什么原理？并发处理性能如何？请继续接着看下文。</p>
<p>　　我们有的时候，为了提高单个节点的通信吞吐量，提高通信性能。如果是基于Java后端的，一般首选的是NIO框架（No-block IO）。但是问题也来了，Java的NIO掌握起来要相当的技术功底，和足够的技术积累，使用起来才能得心应手。一般的开发人员，如果要使用NIO开发一个后端的TCP/HTTP服务器，附带考虑TCP粘包、网络通信异常、消息链接处理等等网络通信细节，开发门槛太高，所以比较明智的选择是，采用业界主流的NIO框架进行服务器后端开发。主流的NIO框架主要有Netty、Mina。它们主要都是基于TCP通信，非阻塞的IO、灵活的IO线程池而设计的，应对高并发请求也是绰绰有余。随着Netty、Mina这样优秀的NIO框架，设计上日趋完善，Java后端高性能服务器开发，在技术上提供了有力的支持保障，从而打破了C++在服务器后端，一统天下的局面。因为在此之前，Java的NIO一直受人诟病，让人敬而远之！</p>
<p>　　既然，这个RPC服务器是基于Netty的，那就在说说Netty吧。实际上Netty是对JAVA NIO框架的再次封装，它的开源网址是<a title="http://netty.io/" href="http://netty.io/" target="_blank">http://netty.io/</a>，本文中使用的Netty版本是：4.0版本，可以通过<a title="http://dl.bintray.com/netty/downloads/netty-4.0.37.Final.tar.bz2" href="http://dl.bintray.com/netty/downloads/netty-4.0.37.Final.tar.bz2" target="_blank">http://dl.bintray.com/netty/downloads/netty-4.0.37.Final.tar.bz2</a>，进行下载使用。那也许你会问，如何使用Netty进行RPC服务器的开发呢？实际不难，下面我就简单的说明一下技术原理：</p>
<p>　　1、定义RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息。</p>
<p>　　2、服务端初始化的时候通过容器加载RPC接口定义和RPC接口实现类对象的映射关系，然后等待客户端发起调用请求。</p>
<p>　　3、客户端发起的RPC消息里面包含，远程调用的类名、方法名称、参数结构、参数值等信息，通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端接口映射的具体实现对象。</p>
<p>　　4、RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</p>
<p>　　5、客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。</p>
<p>　　上面说的是很简单，但是实现的时候，我们还要考虑如下的问题：</p>
<p>　　1、RPC服务器的传输层是基于TCP协议的，出现粘包咋办？这样客户端的请求，服务端不是会解析失败？好在Netty里面已经提供了解决TCP粘包问题的解码器：LengthFieldBasedFrameDecoder，可以靠它轻松搞定TCP粘包问题。</p>
<p>　　2、Netty服务端的线程模型是单线程、多线程（一个线程负责客户端连接，连接成功之后，丢给后端IO的线程池处理）、还是主从模式（客户端连接、后端IO处理都是基于线程池的实现）。当然在这里，我出于性能考虑，使用了Netty主从线程池模型。</p>
<p>　　3、Netty的IO处理线程池，如果遇到非常耗时的业务，出现阻塞了咋办？这样不是很容易把后端的NIO线程给挂死、阻塞？本文的处理方式是，对于复杂的后端业务，分派到专门的业务线程池里面，进行异步回调处理。</p>
<p>　　4、RPC消息的传输是通过字节流在NIO的通道（Channel）之间传输，那具体如何实现呢？本文，是通过基于Java原生对象序列化机制的编码、解码器（ObjectEncoder、ObjectDecoder）进行实现的。当然出于性能考虑，这个可能不是最优的方案。更优的方案是把消息的编码、解码器，搞成可以配置实现的。具体比如可以通过：protobuf、JBoss&nbsp;Marshalling方式进行解码和编码，以提高网络消息的传输效率。</p>
<p>　　5、RPC服务器要考虑多线程、高并发的使用场景，所以线程安全是必须的。此外尽量不要使用synchronized进行加锁，改用轻量级的ReentrantLock方式进行代码块的条件加锁。比如本文中的RPC消息处理回调，就有这方面的使用。</p>
<p>　　6、RPC服务端的服务接口对象和服务接口实现对象要能轻易的配置，轻松进行加载、卸载。在这里，本文是通过Spring容器进行统一的对象管理。</p>
<p>　　综上所述，本文设计的RPC服务器调用的流程图如下所示：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625010800906-382334403.jpg" alt=""></p>
<p>　　客户端并发发起RPC调用请求，然后RPC服务端使用Netty连接器，分派出N个NIO连接线程，这个时候Netty连接器的任务结束。然后NIO连接线程是统一放到Netty NIO处理线程池进行管理，这个线程池里面会对具体的RPC请求连接进行消息编码、消息解码、消息处理等等一系列操作。最后进行消息处理（Handler）的时候，处于性能考虑，这里的设计是，直接把复杂的消息处理过程，丢给专门的RPC业务处理线程池集中处理，然后Handler对应的NIO线程就立即返回、不会阻塞。这个时候RPC调用结束，客户端会异步等待服务端消息的处理结果，本文是通过消息回调机制实现（MessageCallBack）。</p>
<p>　　再来说一说Netty对于RPC消息的解码、编码、处理对应的模块和流程，具体如下图所示：</p>
<p>&nbsp; &nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625185231141-1672009514.jpg" alt=""></p>
<p>　　从上图可以看出客户端、服务端对RPC消息编码、解码、处理调用的模块以及调用顺序了。Netty就是把这样一个一个的处理器串在一起，形成一个责任链，统一进行调用。</p>
<p>　　说了这么多，现在先简单看下，我设计实现的NettyRPC的代码目录层级结构：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625010518766-1194749946.jpg" alt=""></p>
<p>　　其中newlandframework.netty.rpc.core包是NettyRPC的核心实现。newlandframework.netty.rpc.model包里面，则封装了RPC消息请求、应答报文结构，以及RPC服务接口与实现绑定关系的容器定义。newlandframework.netty.rpc.config里面定义了NettyRPC的服务端文件配置属性。</p>
<p>　　下面先来看下newlandframework.netty.rpc.model包中定义的内容。具体是RPC消息请求、应答消息的结构定义：</p>
<p>　　RPC请求消息结构</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageRequest.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc服务请求结构
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.model;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.Serializable;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.lang.builder.ToStringBuilder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.lang.builder.ToStringStyle;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageRequest <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Serializable {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String messageId;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String className;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String methodName;
    </span><span style="color: #0000ff;">private</span> Class&lt;?&gt;<span style="color: #000000;">[] typeParameters;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Object[] parametersVal;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getMessageId() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> messageId;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setMessageId(String messageId) {
        </span><span style="color: #0000ff;">this</span>.messageId =<span style="color: #000000;"> messageId;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getClassName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> className;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setClassName(String className) {
        </span><span style="color: #0000ff;">this</span>.className =<span style="color: #000000;"> className;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getMethodName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> methodName;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setMethodName(String methodName) {
        </span><span style="color: #0000ff;">this</span>.methodName =<span style="color: #000000;"> methodName;
    }

    </span><span style="color: #0000ff;">public</span> Class&lt;?&gt;<span style="color: #000000;">[] getTypeParameters() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> typeParameters;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setTypeParameters(Class&lt;?&gt;<span style="color: #000000;">[] typeParameters) {
        </span><span style="color: #0000ff;">this</span>.typeParameters =<span style="color: #000000;"> typeParameters;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object[] getParameters() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> parametersVal;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setParameters(Object[] parametersVal) {
        </span><span style="color: #0000ff;">this</span>.parametersVal =<span style="color: #000000;"> parametersVal;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> ToStringBuilder(<span style="color: #0000ff;">this</span><span style="color: #000000;">, ToStringStyle.SHORT_PREFIX_STYLE)
                .append(</span>"messageId", messageId).append("className"<span style="color: #000000;">, className)
                .append(</span>"methodName"<span style="color: #000000;">, methodName).toString();
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　RPC应答消息结构</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageResponse.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc服务应答结构
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.model;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.Serializable;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.lang.builder.ToStringBuilder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.lang.builder.ToStringStyle;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageResponse <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Serializable {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String messageId;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String error;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Object resultDesc;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getMessageId() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> messageId;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setMessageId(String messageId) {
        </span><span style="color: #0000ff;">this</span>.messageId =<span style="color: #000000;"> messageId;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getError() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> error;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setError(String error) {
        </span><span style="color: #0000ff;">this</span>.error =<span style="color: #000000;"> error;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object getResult() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> resultDesc;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setResult(Object resultDesc) {
        </span><span style="color: #0000ff;">this</span>.resultDesc =<span style="color: #000000;"> resultDesc;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> ToStringBuilder(<span style="color: #0000ff;">this</span><span style="color: #000000;">, ToStringStyle.SHORT_PREFIX_STYLE)
                .append(</span>"messageId", messageId).append("error"<span style="color: #000000;">, error).toString();
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　RPC服务接口定义、服务接口实现绑定关系容器定义，提供给spring作为容器使用。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageKeyVal.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc服务映射容器
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.model;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MessageKeyVal {

    </span><span style="color: #0000ff;">private</span> Map&lt;String, Object&gt;<span style="color: #000000;"> messageKeyVal;

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setMessageKeyVal(Map&lt;String, Object&gt;<span style="color: #000000;"> messageKeyVal) {
        </span><span style="color: #0000ff;">this</span>.messageKeyVal =<span style="color: #000000;"> messageKeyVal;
    }

    </span><span style="color: #0000ff;">public</span> Map&lt;String, Object&gt;<span style="color: #000000;"> getMessageKeyVal() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> messageKeyVal;
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　好了，定义好核心模型结构之后，现在再向大家展示一下NettyRPC核心包：newlandframework.netty.rpc.core的关键部分实现代码，首先是业务线程池相关类的实现代码，具体如下：</p>
<p>　　线程工厂定义实现</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:NamedThreadFactory.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:线程工厂
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadFactory;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.atomic.AtomicInteger;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> NamedThreadFactory <span style="color: #0000ff;">implements</span><span style="color: #000000;"> ThreadFactory {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> AtomicInteger threadNumber = <span style="color: #0000ff;">new</span> AtomicInteger(1<span style="color: #000000;">);

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> AtomicInteger mThreadNum = <span style="color: #0000ff;">new</span> AtomicInteger(1<span style="color: #000000;">);

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String prefix;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> daemoThread;

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> ThreadGroup threadGroup;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> NamedThreadFactory() {
        </span><span style="color: #0000ff;">this</span>("rpcserver-threadpool-" + threadNumber.getAndIncrement(), <span style="color: #0000ff;">false</span><span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> NamedThreadFactory(String prefix) {
        </span><span style="color: #0000ff;">this</span>(prefix, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span> NamedThreadFactory(String prefix, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> daemo) {
        </span><span style="color: #0000ff;">this</span>.prefix = prefix + "-thread-"<span style="color: #000000;">;
        daemoThread </span>=<span style="color: #000000;"> daemo;
        SecurityManager s </span>=<span style="color: #000000;"> System.getSecurityManager();
        threadGroup </span>= (s == <span style="color: #0000ff;">null</span>) ?<span style="color: #000000;"> Thread.currentThread().getThreadGroup() : s.getThreadGroup();
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Thread newThread(Runnable runnable) {
        String name </span>= prefix +<span style="color: #000000;"> mThreadNum.getAndIncrement();
        Thread ret </span>= <span style="color: #0000ff;">new</span> Thread(threadGroup, runnable, name, 0<span style="color: #000000;">);
        ret.setDaemon(daemoThread);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ret;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ThreadGroup getThreadGroup() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> threadGroup;
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　业务线程池定义实现</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:RpcThreadPool.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc线程池封装
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.Executor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.LinkedBlockingQueue;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.SynchronousQueue;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadPoolExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.TimeUnit;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RpcThreadPool {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">独立出线程池主要是为了应对复杂耗I/O操作的业务，不阻塞netty的handler线程而引入
    </span><span style="color: #008000;">//</span><span style="color: #008000;">当然如果业务足够简单，把处理逻辑写入netty的handler（ChannelInboundHandlerAdapter）也未尝不可</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> Executor getExecutor(<span style="color: #0000ff;">int</span> threads, <span style="color: #0000ff;">int</span><span style="color: #000000;"> queues) {
        String name </span>= "RpcThreadPool"<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> ThreadPoolExecutor(threads, threads, 0<span style="color: #000000;">, TimeUnit.MILLISECONDS,
                queues </span>== 0 ? <span style="color: #0000ff;">new</span> SynchronousQueue&lt;Runnable&gt;<span style="color: #000000;">()
                        : (queues </span>&lt; 0 ? <span style="color: #0000ff;">new</span> LinkedBlockingQueue&lt;Runnable&gt;<span style="color: #000000;">()
                                : </span><span style="color: #0000ff;">new</span> LinkedBlockingQueue&lt;Runnable&gt;<span style="color: #000000;">(queues)),
                </span><span style="color: #0000ff;">new</span> NamedThreadFactory(name, <span style="color: #0000ff;">true</span>), <span style="color: #0000ff;">new</span><span style="color: #000000;"> AbortPolicyWithReport(name));
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:AbortPolicyWithReport.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:线程池异常策略
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.RejectedExecutionException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadPoolExecutor;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> AbortPolicyWithReport <span style="color: #0000ff;">extends</span><span style="color: #000000;"> ThreadPoolExecutor.AbortPolicy {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> String threadName;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> AbortPolicyWithReport(String threadName) {
        </span><span style="color: #0000ff;">this</span>.threadName =<span style="color: #000000;"> threadName;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        String msg </span>= String.format("RpcServer["
                + " Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),"
                + " Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s)]"<span style="color: #000000;">,
                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),
                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating());
        System.out.println(msg);
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> RejectedExecutionException(msg);
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　RPC调用客户端定义实现</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageSendExecutor.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc客户端执行模块
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Proxy;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MessageSendExecutor {

    </span><span style="color: #0000ff;">private</span> RpcServerLoader loader =<span style="color: #000000;"> RpcServerLoader.getInstance();

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageSendExecutor(String serverAddress) {
        loader.load(serverAddress);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> stop() {
        loader.unLoad();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;T&gt; T execute(Class&lt;T&gt;<span style="color: #000000;"> rpcInterface) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> (T) Proxy.newProxyInstance(
                rpcInterface.getClassLoader(),
                </span><span style="color: #0000ff;">new</span> Class&lt;?&gt;<span style="color: #000000;">[]{rpcInterface},
                </span><span style="color: #0000ff;">new</span> MessageSendProxy&lt;T&gt;<span style="color: #000000;">(rpcInterface)
        );
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　这里的RPC客户端实际上，是动态代理了MessageSendProxy，当然这里是应用了，JDK原生的动态代理实现，你还可以改成CGLIB（Code Generation Library）方式。不过本人测试了一下CGLIB方式，在高并发的情况下面会出现空指针异常，但是同样的情况，JDK原生的动态代理却没有问题。并发程度不高的情况下面，两种代理方式都运行正常。后续再深入研究看看吧！废话不说了，现在给出MessageSendProxy的实现方式</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageSendProxy.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc客户端消息处理
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.InvocationHandler;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.lang.reflect.Method;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.UUID;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageRequest;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageSendProxy&lt;T&gt; <span style="color: #0000ff;">implements</span><span style="color: #000000;"> InvocationHandler {

    </span><span style="color: #0000ff;">private</span> Class&lt;T&gt;<span style="color: #000000;"> cls;

    </span><span style="color: #0000ff;">public</span> MessageSendProxy(Class&lt;T&gt;<span style="color: #000000;"> cls) {
        </span><span style="color: #0000ff;">this</span>.cls =<span style="color: #000000;"> cls;
    }

    </span><span style="color: #0000ff;">public</span> Object invoke(Object proxy, Method method, Object[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
        MessageRequest request </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageRequest();
        request.setMessageId(UUID.randomUUID().toString());
        request.setClassName(method.getDeclaringClass().getName());
        request.setMethodName(method.getName());
        request.setTypeParameters(method.getParameterTypes());
        request.setParameters(args);

        MessageSendHandler handler </span>=<span style="color: #000000;"> RpcServerLoader.getInstance().getMessageSendHandler();
        MessageCallBack callBack </span>=<span style="color: #000000;"> handler.sendRequest(request);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callBack.start();
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　进一步发现MessageSendProxy其实是把消息发送给RpcServerLoader模块，它的代码如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:RpcServerLoader.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc服务器配置加载
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.EventLoopGroup;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.nio.NioEventLoopGroup;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.InetSocketAddress;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadPoolExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.Condition;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.Lock;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.ReentrantLock;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.serialize.support.RpcSerializeProtocol;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RpcServerLoader {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> RpcServerLoader rpcServerLoader;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">static</span> String DELIMITER = ":"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> RpcSerializeProtocol serializeProtocol =<span style="color: #000000;"> RpcSerializeProtocol.JDKSERIALIZE;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">方法返回到Java虚拟机的可用的处理器数量</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> parallel = Runtime.getRuntime().availableProcessors() * 2<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">netty nio线程池</span>
    <span style="color: #0000ff;">private</span> EventLoopGroup eventLoopGroup = <span style="color: #0000ff;">new</span><span style="color: #000000;"> NioEventLoopGroup(parallel);
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) RpcThreadPool.getExecutor(16, -1<span style="color: #000000;">);
    </span><span style="color: #0000ff;">private</span> MessageSendHandler messageSendHandler = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">等待Netty服务端链路建立通知信号</span>
    <span style="color: #0000ff;">private</span> Lock lock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ReentrantLock();
    </span><span style="color: #0000ff;">private</span> Condition signal =<span style="color: #000000;"> lock.newCondition();

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> RpcServerLoader() {
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">并发双重锁定</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> RpcServerLoader getInstance() {
        </span><span style="color: #0000ff;">if</span> (rpcServerLoader == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">synchronized</span> (RpcServerLoader.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (rpcServerLoader == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    rpcServerLoader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> RpcServerLoader();
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> rpcServerLoader;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> load(String serverAddress, RpcSerializeProtocol serializeProtocol) {
        String[] ipAddr </span>=<span style="color: #000000;"> serverAddress.split(RpcServerLoader.DELIMITER);
        </span><span style="color: #0000ff;">if</span> (ipAddr.length == 2<span style="color: #000000;">) {
            String host </span>= ipAddr[0<span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> port = Integer.parseInt(ipAddr[1<span style="color: #000000;">]);
            </span><span style="color: #0000ff;">final</span> InetSocketAddress remoteAddr = <span style="color: #0000ff;">new</span><span style="color: #000000;"> InetSocketAddress(host, port);

            threadPoolExecutor.submit(</span><span style="color: #0000ff;">new</span> MessageSendInitializeTask(eventLoopGroup, remoteAddr, <span style="color: #0000ff;">this</span><span style="color: #000000;">, serializeProtocol));
        }
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setMessageSendHandler(MessageSendHandler messageInHandler) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            lock.lock();
            </span><span style="color: #0000ff;">this</span>.messageSendHandler =<span style="color: #000000;"> messageInHandler;
            </span><span style="color: #008000;">//</span><span style="color: #008000;">唤醒所有等待客户端RPC线程</span>
<span style="color: #000000;">            signal.signalAll();
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            lock.unlock();
        }
    }

    </span><span style="color: #0000ff;">public</span> MessageSendHandler getMessageSendHandler() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            lock.lock();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Netty服务端链路没有建立完毕之前，先挂起等待</span>
            <span style="color: #0000ff;">if</span> (messageSendHandler == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                signal.await();
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> messageSendHandler;
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            lock.unlock();
        }
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> unLoad() {
        messageSendHandler.close();
        threadPoolExecutor.shutdown();
        eventLoopGroup.shutdownGracefully();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setSerializeProtocol(RpcSerializeProtocol serializeProtocol) {
        </span><span style="color: #0000ff;">this</span>.serializeProtocol =<span style="color: #000000;"> serializeProtocol;
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　好了，现在一次性给出RPC客户端消息编码、解码、处理的模块实现代码。</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageSendInitializeTask.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc客户端线程任务处理
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.bootstrap.Bootstrap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFuture;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFutureListener;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelOption;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.EventLoopGroup;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.socket.nio.NioSocketChannel;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.InetSocketAddress;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageSendInitializeTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {

    </span><span style="color: #0000ff;">private</span> EventLoopGroup eventLoopGroup = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> InetSocketAddress serverAddress = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> RpcServerLoader loader = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    MessageSendInitializeTask(EventLoopGroup eventLoopGroup, InetSocketAddress serverAddress, RpcServerLoader loader) {
        </span><span style="color: #0000ff;">this</span>.eventLoopGroup =<span style="color: #000000;"> eventLoopGroup;
        </span><span style="color: #0000ff;">this</span>.serverAddress =<span style="color: #000000;"> serverAddress;
        </span><span style="color: #0000ff;">this</span>.loader =<span style="color: #000000;"> loader;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        Bootstrap b </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Bootstrap();
        b.group(eventLoopGroup)
                .channel(NioSocketChannel.</span><span style="color: #0000ff;">class</span>).option(ChannelOption.SO_KEEPALIVE, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        b.handler(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageSendChannelInitializer());

        ChannelFuture channelFuture </span>=<span style="color: #000000;"> b.connect(serverAddress);
        channelFuture.addListener(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ChannelFutureListener() {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> operationComplete(<span style="color: #0000ff;">final</span> ChannelFuture channelFuture) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (channelFuture.isSuccess()) {
                    MessageSendHandler handler </span>= channelFuture.channel().pipeline().get(MessageSendHandler.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
                    MessageSendInitializeTask.</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.loader.setMessageSendHandler(handler);
                }
            }
        });
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageSendChannelInitializer.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc客户端管道初始化
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelInitializer;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelPipeline;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.socket.SocketChannel;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.LengthFieldBasedFrameDecoder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.LengthFieldPrepender;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ClassResolvers;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ObjectDecoder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ObjectEncoder;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageSendChannelInitializer <span style="color: #0000ff;">extends</span> ChannelInitializer&lt;SocketChannel&gt;<span style="color: #000000;"> {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">ObjectDecoder 底层默认继承半包解码器LengthFieldBasedFrameDecoder处理粘包问题的时候，
    </span><span style="color: #008000;">//</span><span style="color: #008000;">消息头开始即为长度字段，占据4个字节。这里出于保持兼容的考虑</span>
    <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> MESSAGE_LENGTH = 4<span style="color: #000000;">;

    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> initChannel(SocketChannel socketChannel) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        ChannelPipeline pipeline </span>=<span style="color: #000000;"> socketChannel.pipeline();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">ObjectDecoder的基类半包解码器LengthFieldBasedFrameDecoder的报文格式保持兼容。因为底层的父类LengthFieldBasedFrameDecoder
        </span><span style="color: #008000;">//</span><span style="color: #008000;">的初始化参数即为super(maxObjectSize, 0, 4, 0, 4);</span>
        pipeline.addLast(<span style="color: #0000ff;">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, MessageSendChannelInitializer.MESSAGE_LENGTH, 0<span style="color: #000000;">, MessageSendChannelInitializer.MESSAGE_LENGTH));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">利用LengthFieldPrepender回填补充ObjectDecoder消息报文头</span>
        pipeline.addLast(<span style="color: #0000ff;">new</span><span style="color: #000000;"> LengthFieldPrepender(MessageSendChannelInitializer.MESSAGE_LENGTH));
        pipeline.addLast(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ObjectEncoder());
        </span><span style="color: #008000;">//</span><span style="color: #008000;">考虑到并发性能，采用weakCachingConcurrentResolver缓存策略。一般情况使用:cacheDisabled即可</span>
        pipeline.addLast(<span style="color: #0000ff;">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.weakCachingConcurrentResolver(<span style="color: #0000ff;">this</span><span style="color: #000000;">.getClass().getClassLoader())));
        pipeline.addLast(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageSendHandler());
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageSendHandler.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc客户端处理模块
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.buffer.Unpooled;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.Channel;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFutureListener;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelHandlerContext;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelInboundHandlerAdapter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.net.SocketAddress;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ConcurrentHashMap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageResponse;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageSendHandler <span style="color: #0000ff;">extends</span><span style="color: #000000;"> ChannelInboundHandlerAdapter {

    </span><span style="color: #0000ff;">private</span> ConcurrentHashMap&lt;String, MessageCallBack&gt; mapCallBack = <span style="color: #0000ff;">new</span> ConcurrentHashMap&lt;String, MessageCallBack&gt;<span style="color: #000000;">();

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">volatile</span><span style="color: #000000;"> Channel channel;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> SocketAddress remoteAddr;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Channel getChannel() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> channel;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> SocketAddress getRemoteAddr() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> remoteAddr;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> channelActive(ChannelHandlerContext ctx) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.channelActive(ctx);
        </span><span style="color: #0000ff;">this</span>.remoteAddr = <span style="color: #0000ff;">this</span><span style="color: #000000;">.channel.remoteAddress();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> channelRegistered(ChannelHandlerContext ctx) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.channelRegistered(ctx);
        </span><span style="color: #0000ff;">this</span>.channel =<span style="color: #000000;"> ctx.channel();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        MessageResponse response </span>=<span style="color: #000000;"> (MessageResponse) msg;
        String messageId </span>=<span style="color: #000000;"> response.getMessageId();
        MessageCallBack callBack </span>=<span style="color: #000000;"> mapCallBack.get(messageId);
        </span><span style="color: #0000ff;">if</span> (callBack != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            mapCallBack.remove(messageId);
            callBack.over(response);
        }
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        ctx.close();
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> close() {
        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageCallBack sendRequest(MessageRequest request) {
        MessageCallBack callBack </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageCallBack(request);
        mapCallBack.put(request.getMessageId(), callBack);
        channel.writeAndFlush(request);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callBack;
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　最后给出RPC服务端的实现。首先是通过spring自动加载RPC服务接口、接口实现容器绑定加载，初始化Netty主/从线程池等操作，具体是通过MessageRecvExecutor模块实现的，现在给出实现代码：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageRecvExecutor.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc服务器执行模块
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.bootstrap.ServerBootstrap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFuture;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelOption;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.EventLoopGroup;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.nio.NioEventLoopGroup;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.socket.nio.NioServerSocketChannel;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.nio.channels.spi.SelectorProvider;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Iterator;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Set;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ConcurrentHashMap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadFactory;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.ThreadPoolExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.logging.Level;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageKeyVal;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.beans.BeansException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.beans.factory.InitializingBean;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.context.ApplicationContext;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.springframework.context.ApplicationContextAware;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageRecvExecutor <span style="color: #0000ff;">implements</span><span style="color: #000000;"> ApplicationContextAware, InitializingBean {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String serverAddress;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">static</span> String DELIMITER = ":"<span style="color: #000000;">;

    </span><span style="color: #0000ff;">private</span> Map&lt;String, Object&gt; handlerMap = <span style="color: #0000ff;">new</span> ConcurrentHashMap&lt;String, Object&gt;<span style="color: #000000;">();

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> ThreadPoolExecutor threadPoolExecutor;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageRecvExecutor(String serverAddress) {
        </span><span style="color: #0000ff;">this</span>.serverAddress =<span style="color: #000000;"> serverAddress;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> submit(Runnable task) {
        </span><span style="color: #0000ff;">if</span> (threadPoolExecutor == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">synchronized</span> (MessageRecvExecutor.<span style="color: #0000ff;">class</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (threadPoolExecutor == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                    threadPoolExecutor </span>= (ThreadPoolExecutor) RpcThreadPool.getExecutor(16, -1<span style="color: #000000;">);
                }
            }
        }
        threadPoolExecutor.submit(task);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setApplicationContext(ApplicationContext ctx) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> BeansException {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            MessageKeyVal keyVal </span>= (MessageKeyVal) ctx.getBean(Class.forName("newlandframework.netty.rpc.model.MessageKeyVal"<span style="color: #000000;">));
            Map</span>&lt;String, Object&gt; rpcServiceObject =<span style="color: #000000;"> keyVal.getMessageKeyVal();

            Set s </span>=<span style="color: #000000;"> rpcServiceObject.entrySet();
            Iterator</span>&lt;Map.Entry&lt;String, Object&gt;&gt; it =<span style="color: #000000;"> s.iterator();
            Map.Entry</span>&lt;String, Object&gt;<span style="color: #000000;"> entry;

            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (it.hasNext()) {
                entry </span>=<span style="color: #000000;"> it.next();
                handlerMap.put(entry.getKey(), entry.getValue());
            }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MessageRecvExecutor.</span><span style="color: #0000ff;">class</span>.getName()).log(Level.SEVERE, <span style="color: #0000ff;">null</span><span style="color: #000000;">, ex);
        }
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> afterPropertiesSet() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">netty的线程池模型设置成主从线程池模式，这样可以应对高并发请求
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当然netty还支持单线程、多线程网络IO模型，可以根据业务需求灵活配置</span>
        ThreadFactory threadRpcFactory = <span style="color: #0000ff;">new</span> NamedThreadFactory("NettyRPC ThreadFactory"<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方法返回到Java虚拟机的可用的处理器数量</span>
        <span style="color: #0000ff;">int</span> parallel = Runtime.getRuntime().availableProcessors() * 2<span style="color: #000000;">;
    
        EventLoopGroup boss </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> NioEventLoopGroup();
        EventLoopGroup worker </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> NioEventLoopGroup(parallel,threadRpcFactory,SelectorProvider.provider());
        
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            ServerBootstrap bootstrap </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ServerBootstrap();
            bootstrap.group(boss, worker).channel(NioServerSocketChannel.</span><span style="color: #0000ff;">class</span><span style="color: #000000;">)
                    .childHandler(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageRecvChannelInitializer(handlerMap))
                    .option(ChannelOption.SO_BACKLOG, </span>128<span style="color: #000000;">)
                    .childOption(ChannelOption.SO_KEEPALIVE, </span><span style="color: #0000ff;">true</span><span style="color: #000000;">);

            String[] ipAddr </span>=<span style="color: #000000;"> serverAddress.split(MessageRecvExecutor.DELIMITER);

            </span><span style="color: #0000ff;">if</span> (ipAddr.length == 2<span style="color: #000000;">) {
                String host </span>= ipAddr[0<span style="color: #000000;">];
                </span><span style="color: #0000ff;">int</span> port = Integer.parseInt(ipAddr[1<span style="color: #000000;">]);
                ChannelFuture future </span>=<span style="color: #000000;"> bootstrap.bind(host, port).sync();
                System.out.printf(</span>"[author tangjie] Netty RPC Server start success ip:%s port:%d\n"<span style="color: #000000;">, host, port);
                future.channel().closeFuture().sync();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                System.out.printf(</span>"[author tangjie] Netty RPC Server start fail!\n"<span style="color: #000000;">);
            }
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            worker.shutdownGracefully();
            boss.shutdownGracefully();
        }
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　最后还是老规矩，给出RPC服务端消息编码、解码、处理的核心模块代码实现，具体如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageRecvChannelInitializer.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc服务端管道初始化
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelInitializer;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelPipeline;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.socket.SocketChannel;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.LengthFieldBasedFrameDecoder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.LengthFieldPrepender;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ClassResolvers;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ObjectDecoder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.handler.codec.serialization.ObjectEncoder;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageRecvChannelInitializer <span style="color: #0000ff;">extends</span> ChannelInitializer&lt;SocketChannel&gt;<span style="color: #000000;"> {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">ObjectDecoder 底层默认继承半包解码器LengthFieldBasedFrameDecoder处理粘包问题的时候，
    </span><span style="color: #008000;">//</span><span style="color: #008000;">消息头开始即为长度字段，占据4个字节。这里出于保持兼容的考虑</span>
    <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> MESSAGE_LENGTH = 4<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> Map&lt;String, Object&gt; handlerMap = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    MessageRecvChannelInitializer(Map</span>&lt;String, Object&gt;<span style="color: #000000;"> handlerMap) {
        </span><span style="color: #0000ff;">this</span>.handlerMap =<span style="color: #000000;"> handlerMap;
    }

    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> initChannel(SocketChannel socketChannel) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        ChannelPipeline pipeline </span>=<span style="color: #000000;"> socketChannel.pipeline();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">ObjectDecoder的基类半包解码器LengthFieldBasedFrameDecoder的报文格式保持兼容。因为底层的父类LengthFieldBasedFrameDecoder
        </span><span style="color: #008000;">//</span><span style="color: #008000;">的初始化参数即为super(maxObjectSize, 0, 4, 0, 4); </span>
        pipeline.addLast(<span style="color: #0000ff;">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, MessageRecvChannelInitializer.MESSAGE_LENGTH, 0<span style="color: #000000;">, MessageRecvChannelInitializer.MESSAGE_LENGTH));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">利用LengthFieldPrepender回填补充ObjectDecoder消息报文头</span>
        pipeline.addLast(<span style="color: #0000ff;">new</span><span style="color: #000000;"> LengthFieldPrepender(MessageRecvChannelInitializer.MESSAGE_LENGTH));
        pipeline.addLast(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ObjectEncoder());
        </span><span style="color: #008000;">//</span><span style="color: #008000;">考虑到并发性能，采用weakCachingConcurrentResolver缓存策略。一般情况使用:cacheDisabled即可</span>
        pipeline.addLast(<span style="color: #0000ff;">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.weakCachingConcurrentResolver(<span style="color: #0000ff;">this</span><span style="color: #000000;">.getClass().getClassLoader())));
        pipeline.addLast(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageRecvHandler(handlerMap));
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageRecvHandler.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc服务器消息处理
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelHandlerContext;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelInboundHandlerAdapter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageResponse;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageRecvHandler <span style="color: #0000ff;">extends</span><span style="color: #000000;"> ChannelInboundHandlerAdapter {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Map&lt;String, Object&gt;<span style="color: #000000;"> handlerMap;

    </span><span style="color: #0000ff;">public</span> MessageRecvHandler(Map&lt;String, Object&gt;<span style="color: #000000;"> handlerMap) {
        </span><span style="color: #0000ff;">this</span>.handlerMap =<span style="color: #000000;"> handlerMap;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        MessageRequest request </span>=<span style="color: #000000;"> (MessageRequest) msg;
        MessageResponse response </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageResponse();
        MessageRecvInitializeTask recvTask </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MessageRecvInitializeTask(request, response, handlerMap, ctx);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">不要阻塞nio线程，复杂的业务逻辑丢给专门的线程池</span>
<span style="color: #000000;">        MessageRecvExecutor.submit(recvTask);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">网络有异常要关闭通道</span>
<span style="color: #000000;">        ctx.close();
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageRecvInitializeTask.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc服务器消息线程任务处理
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFuture;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelFutureListener;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> io.netty.channel.ChannelHandlerContext;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Map;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageResponse;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.beanutils.MethodUtils;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MessageRecvInitializeTask <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {

    </span><span style="color: #0000ff;">private</span> MessageRequest request = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> MessageResponse response = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> Map&lt;String, Object&gt; handlerMap = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> ChannelHandlerContext ctx = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageResponse getResponse() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> response;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageRequest getRequest() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> request;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setRequest(MessageRequest request) {
        </span><span style="color: #0000ff;">this</span>.request =<span style="color: #000000;"> request;
    }

    MessageRecvInitializeTask(MessageRequest request, MessageResponse response, Map</span>&lt;String, Object&gt;<span style="color: #000000;"> handlerMap, ChannelHandlerContext ctx) {
        </span><span style="color: #0000ff;">this</span>.request =<span style="color: #000000;"> request;
        </span><span style="color: #0000ff;">this</span>.response =<span style="color: #000000;"> response;
        </span><span style="color: #0000ff;">this</span>.handlerMap =<span style="color: #000000;"> handlerMap;
        </span><span style="color: #0000ff;">this</span>.ctx =<span style="color: #000000;"> ctx;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        response.setMessageId(request.getMessageId());
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Object result </span>=<span style="color: #000000;"> reflect(request);
            response.setResult(result);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Throwable t) {
            response.setError(t.toString());
            t.printStackTrace();
            System.err.printf(</span>"RPC Server invoke error!\n"<span style="color: #000000;">);
        }

        ctx.writeAndFlush(response).addListener(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ChannelFutureListener() {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> operationComplete(ChannelFuture channelFuture) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
                System.out.println(</span>"RPC Server Send message-id respone:" +<span style="color: #000000;"> request.getMessageId());
            }
        });
    }

    </span><span style="color: #0000ff;">private</span> Object reflect(MessageRequest request) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
        String className </span>=<span style="color: #000000;"> request.getClassName();
        Object serviceBean </span>=<span style="color: #000000;"> handlerMap.get(className);
        String methodName </span>=<span style="color: #000000;"> request.getMethodName();
        Object[] parameters </span>=<span style="color: #000000;"> request.getParameters();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> MethodUtils.invokeMethod(serviceBean, methodName, parameters);
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　然后是RPC消息处理的回调实现模块代码</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:MessageCallBack.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:Rpc消息回调
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.core;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.TimeUnit;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.Condition;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.Lock;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.locks.ReentrantLock;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.model.MessageResponse;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MessageCallBack {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MessageRequest request;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MessageResponse response;
    </span><span style="color: #0000ff;">private</span> Lock lock = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ReentrantLock();
    </span><span style="color: #0000ff;">private</span> Condition finish =<span style="color: #000000;"> lock.newCondition();

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MessageCallBack(MessageRequest request) {
        </span><span style="color: #0000ff;">this</span>.request =<span style="color: #000000;"> request;
    }

    </span><span style="color: #0000ff;">public</span> Object start() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> InterruptedException {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            lock.lock();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">设定一下超时时间，rpc服务器太久没有相应的话，就默认返回空吧。</span>
            finish.await(10*1000<span style="color: #000000;">, TimeUnit.MILLISECONDS);
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.response != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.response.getResult();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            lock.unlock();
        }
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> over(MessageResponse reponse) {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            lock.lock();
            finish.signal();
            </span><span style="color: #0000ff;">this</span>.response =<span style="color: #000000;"> reponse;
        } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
            lock.unlock();
        }
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　到此为止，NettyRPC的关键部分：服务端、客户端的模块已经通过Netty全部实现了。现在给出spring加载配置rpc-invoke-config.xml的内容：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="UTF-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans </span><span style="color: #ff0000;">xmlns</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans"</span><span style="color: #ff0000;">
       xmlns:xsi</span><span style="color: #0000ff;">="http://www.w3.org/2001/XMLSchema-instance"</span><span style="color: #ff0000;">
       xmlns:context</span><span style="color: #0000ff;">="http://www.springframework.org/schema/context"</span><span style="color: #ff0000;">
       xsi:schemaLocation</span><span style="color: #0000ff;">="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:component-scan </span><span style="color: #ff0000;">base-package</span><span style="color: #0000ff;">="newlandframework.netty.rpc.core"</span><span style="color: #0000ff;">/&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">context:property-placeholder </span><span style="color: #ff0000;">location</span><span style="color: #0000ff;">="classpath:newlandframework/netty/rpc/config/rpc-server.properties"</span><span style="color: #0000ff;">/&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="rpcbean"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="newlandframework.netty.rpc.model.MessageKeyVal"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">property </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="messageKeyVal"</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">map</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">entry </span><span style="color: #ff0000;">key</span><span style="color: #0000ff;">="newlandframework.netty.rpc.servicebean.Calculate"</span><span style="color: #0000ff;">&gt;</span>
          <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ref </span><span style="color: #ff0000;">bean</span><span style="color: #0000ff;">="calc"</span><span style="color: #0000ff;">/&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">entry</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">map</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">property</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="calc"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="newlandframework.netty.rpc.servicebean.CalculateImpl"</span><span style="color: #0000ff;">/&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="rpcServer"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="newlandframework.netty.rpc.core.MessageRecvExecutor"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">constructor-arg </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="serverAddress"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="${rpc.server.addr}"</span><span style="color: #0000ff;">/&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　再贴出RPC服务绑定ip信息的配置文件：rpc-server.properties的内容。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#rpc server's ip address config
rpc.server.addr</span>=127.0.0.1:18888</pre>
</div>
<p>　　最后NettyRPC服务端启动方式参考如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">new</span> ClassPathXmlApplicationContext("newlandframework/netty/rpc/config/rpc-invoke-config.xml");</pre>
</div>
<p>　　如果一切顺利，没有出现意外的话，控制台上面，会出现如下截图所示的情况：</p>
<p><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625014824375-1728878897.jpg" alt=""></p>
<p>　　如果出现了，说明NettyRPC服务器，已经启动成功！</p>
<p>　　上面基于Netty的RPC服务器，并发处理性能如何呢？实践是检验真理的唯一标准，下面我们就来实战一下。</p>
<p>　　下面的测试案例，是基于RPC远程调用两数相加函数，并返回计算结果。客户端同时开1W个线程，同一时刻，瞬时发起并发计算请求，然后观察Netty的RPC服务器是否有正常应答回复响应，以及客户端是否有正常返回调用计算结果。值得注意的是，测试案例是基于1W个线程瞬时并发请求而设计的，并不是1W个线程循环发起请求。这两者对于衡量RPC服务器的并发处理性能，还是有很大差别的。当然，前者对于并发性能的处理要求，要高上很多很多。</p>
<p>　　现在，先给出RPC计算接口、RPC计算接口实现类的代码实现：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:Calculate.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:计算器定义接口
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.servicebean;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> Calculate {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">两数相加</span>
    <span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:CalculateImpl.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:计算器定义接口实现
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.servicebean;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalculateImpl <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Calculate {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">两数相加</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　下面是瞬时并发RPC请求的测试样例：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:CalcParallelRequestThread.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:并发线程模拟
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.servicebean;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.core.MessageSendExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.CountDownLatch;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.logging.Level;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.logging.Logger;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> CalcParallelRequestThread <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Runnable {

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> CountDownLatch signal;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> CountDownLatch finish;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MessageSendExecutor executor;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> taskNumber = 0<span style="color: #000000;">;

    </span><span style="color: #0000ff;">public</span> CalcParallelRequestThread(MessageSendExecutor executor, CountDownLatch signal, CountDownLatch finish, <span style="color: #0000ff;">int</span><span style="color: #000000;"> taskNumber) {
        </span><span style="color: #0000ff;">this</span>.signal =<span style="color: #000000;"> signal;
        </span><span style="color: #0000ff;">this</span>.finish =<span style="color: #000000;"> finish;
        </span><span style="color: #0000ff;">this</span>.taskNumber =<span style="color: #000000;"> taskNumber;
        </span><span style="color: #0000ff;">this</span>.executor =<span style="color: #000000;"> executor;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            signal.await();

            Calculate calc </span>= executor.execute(Calculate.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> add =<span style="color: #000000;"> calc.add(taskNumber, taskNumber);
            System.out.println(</span>"calc add result:[" + add + "]"<span style="color: #000000;">);

            finish.countDown();
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException ex) {
            Logger.getLogger(CalcParallelRequestThread.</span><span style="color: #0000ff;">class</span>.getName()).log(Level.SEVERE, <span style="color: #0000ff;">null</span><span style="color: #000000;">, ex);
        }
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
 * @filename:RpcParallelTest.java
 *
 * Newland Co. Ltd. All rights reserved.
 *
 * @Description:rpc并发测试代码
 * </span><span style="color: #808080;">@author</span><span style="color: #008000;"> tangjie
 * </span><span style="color: #808080;">@version</span><span style="color: #008000;"> 1.0
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">package</span><span style="color: #000000;"> newlandframework.netty.rpc.servicebean;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.concurrent.CountDownLatch;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> newlandframework.netty.rpc.core.MessageSendExecutor;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> org.apache.commons.lang.time.StopWatch;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RpcParallelTest {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #0000ff;">final</span> MessageSendExecutor executor = <span style="color: #0000ff;">new</span> MessageSendExecutor("127.0.0.1:18888"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">并行度10000</span>
        <span style="color: #0000ff;">int</span> parallel = 10000<span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">开始计时</span>
        StopWatch sw = <span style="color: #0000ff;">new</span><span style="color: #000000;"> StopWatch();
        sw.start();

        CountDownLatch signal </span>= <span style="color: #0000ff;">new</span> CountDownLatch(1<span style="color: #000000;">);
        CountDownLatch finish </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CountDownLatch(parallel);

        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> index = 0; index &lt; parallel; index++<span style="color: #000000;">) {
            CalcParallelRequestThread client </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> CalcParallelRequestThread(executor, signal, finish, index);
            </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(client).start();
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">10000个并发线程瞬间发起请求操作</span>
<span style="color: #000000;">        signal.countDown();
        finish.await();
        
        sw.stop();

        String tip </span>= String.format("RPC调用总共耗时: [%s] 毫秒"<span style="color: #000000;">, sw.getTime());
        System.out.println(tip);

        executor.stop();
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>　　好了，现在先启动NettyRPC服务器，确认没有问题之后，运行并发RPC请求客户端，看下客户端打印的计算结果，以及处理耗时。</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625090441641-916118510.jpg" alt=""></p>
<p>　　从上面来看，10000个瞬时RPC计算请求，总共耗时接近11秒。我们在来看下NettyRPC的服务端运行情况，如下所示：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625090549563-465927784.jpg" alt=""></p>
<p>　　可以很清楚地看到，RPC服务端都有收到客户端发起的RPC计算请求，并返回消息应答。</p>
<p>　　最后我们还是要分别验证一下，RPC服务端是否存在丢包、粘包、IO阻塞的情况？1W个并发计算请求，是否成功接收处理并应答了？实际情况说明一切，看下图所示：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625090826953-1445487995.jpg" alt=""></p>
<p>&nbsp;　　非常给力，RPC的服务端确实成功接收到了客户端发起的1W笔瞬时并发计算请求，并且成功应答处理了。并没有出现：丢包、粘包、IO阻塞的情况。再看下RPC客户端，是否成功得到计算结果的应答返回了呢？</p>
<p>　　<img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/913759-20160625091005391-1482737387.jpg" alt=""></p>
<p>　　很好，RPC的客户端，确实收到了RPC服务端计算的1W笔加法请求的计算结果，而且耗时接近11秒。由此可见，基于Netty+业务线程池的NettyRPC服务器，应对并发多线程RPC请求，处理起来是得心应手，游刃有余！</p>
<p>　　最后，本文通过Netty这个NIO框架，实现了一个很简单的“高性能”的RPC服务器，代码虽然写出来了，但是还是有一些值得改进的地方，比如：</p>
<p>　　1、对象序列化传输可以支持目前主流的序列化框架：protobuf、JBoss&nbsp;Marshalling、Avro等等。</p>
<p>　　2、Netty的线程模型可以根据业务需求，进行定制。因为，并不是每笔业务都需要这么强大的并发处理性能。</p>
<p>　　3、目前RPC计算只支持一个RPC服务接口映射绑定一个对应的实现，后续要支持一对多的情况。</p>
<p>　　4、业务线程池的启动参数、线程池并发阻塞容器模型等等，可以配置化管理。</p>
<p>　　5、Netty的Handler处理部分，对于复杂的业务逻辑，现在是统一分派到特定的线程池进行后台异步处理。当然你还可以考虑JMS（消息队列）方式进行解耦，统一分派给消息队列的订阅者，统一处理。目前实现JMS的开源框架也有很多，ActiveMQ、RocketMQ等等，都可以考虑。</p>
<p>　　本文实现的NettyRPC，对于面前的您而言，一定还有很多地方，可以加以完善和改进，优化改进的工作就交给您自由发挥了。</p>
<p>　　由于本人技术能力、认知水平有限。本文中有说不对的地方，恳请园友们批评指正！不吝赐教！最后，感谢面前的您，耐心的阅读完本文，相信现在的你，对于Java开发高性能的服务端应用，又有了一个更深入的了解！本文算是对我Netty学习成果的阶段性总结，后续有时间，我还会继续推出Netty工业级开发的相关文章，敬请期待！</p>
<p>　　PS：还有兴趣的朋友可以参考、阅读一下，我的另外一篇文章：<a title="Netty实现高性能RPC服务器优化篇之消息序列化" href="http://www.cnblogs.com/jietang/p/5675171.html" target="_blank">Netty实现高性能RPC服务器优化篇之消息序列化</a>。此外，自从在博客园发表了两篇：基于Netty开发高性能RPC服务器的文章之后，本人收到很多园友们索要源代码进行学习交流的请求。为了方便大家，本人把NettyRPC的代码开源托管到github上面，欢迎有兴趣的朋友一起学习、研究！</p>
<p>　　附上NettyRPC项目的下载路径：<a title="https://github.com/tang-jie/NettyRPC" href="https://github.com/tang-jie/NettyRPC" target="_blank">https://github.com/tang-jie/NettyRPC</a></p>
<p>&nbsp;</p>
<p>　　<span style="color: #0000ff;"><strong>Netty工业级开发系列文章进阶：Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇</strong></span></p>
<p>　　谈谈如何使用Netty开发实现高性能的RPC服务器、Netty实现高性能RPC服务器优化篇之消息序列化。这两篇<span style="color: #000000;">文章主要设计的思路是，基于Netty构建了一个高性能的RPC服务器，而这些前期代码的准备工作，主要是为了设计、实现一个基于Netty的分布式消息队列系统做铺垫，</span><span>本人把这个分布式消息队列系统，命名为：AvatarMQ。作为Netty工业级开发系列的进阶篇，感兴趣的朋友可以点击关注：<a title="http://www.cnblogs.com/jietang/p/5808735.html" href="http://www.cnblogs.com/jietang/p/5808735.html" target="_blank"><span style="color: #000000;">Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇</span></a>，一定不会让您失望！</span></p>
<p><span style="color: #000000;">　　AvatarMQ项目开源网址：<a title="https://github.com/tang-jie/AvatarMQ" href="https://github.com/tang-jie/AvatarMQ" target="_blank"><span style="color: #000000;">https://github.com/tang-jie/AvatarMQ</span></a>。</span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag">标签: <a href="http://www.cnblogs.com/jietang/tag/Java/">Java</a></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(5615681,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;1850cabf-69ea-e511-9fc1-ac853d9f53cc&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/jietang/" target="_blank"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/20160320160025.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/jietang/">Newland</a><br>
            <a href="http://home.cnblogs.com/u/jietang/followees">关注 - 1</a><br>
            <a href="http://home.cnblogs.com/u/jietang/followers">粉丝 - 91</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor">荣誉：<a href="http://www.cnblogs.com/expert/" target="_blank">推荐博客</a></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;1850cabf-69ea-e511-9fc1-ac853d9f53cc&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(5615681,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">23</span>
    </div>
    <div class="buryit" onclick="votePost(5615681,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
</div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/jietang/p/5506373.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/jietang/p/5506373.html" title="发布于2016-05-18 22:58">动手打造自己的跨语言异构模块通信解决方案</a><br><a href="http://www.cnblogs.com/jietang/p/5675171.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/jietang/p/5675171.html" title="发布于2016-07-16 10:49">Netty实现高性能RPC服务器优化篇之消息序列化</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2016-06-25 10:34</span> <a href="http://www.cnblogs.com/jietang/">Newland</a> 阅读(<span id="post_view_count">6797</span>) 评论(<span id="post_comment_count">35</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5615681" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/jietang/p/5615681.html#" onclick="AddToWz(5615681);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=273292,cb_entryId=5615681,cb_blogApp=currentBlogApp,cb_blogUserGuid='1850cabf-69ea-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2016/6/25 10:34:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<br>
<div class="feedback_area_title">评论列表</div>
<div class="feedbackNoItems"></div>	

		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3458565" class="layer">#1楼</a><a name="3458565" id="comment_anchor_3458565"></a>  <span class="comment_date">2016-06-25 10:57</span> <a id="a_comment_author_3458565" href="http://www.cnblogs.com/biakia/" target="_blank">biakia</a> <a href="http://msg.cnblogs.com/send/biakia" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3458565" class="blog_comment_body">实现一个RPC服务器其实很简单，但是仅仅一个RPC服务器在真正的生产环境其实没什么用，作者可以进一步思考一下，实现基于RPC调用的SOA架构，分布式服务的地址如何管理，服务如何发布，如何消费，多版本服务如何管理等等</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3458565,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3458565,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3458565_avatar" style="display:none;">http://pic.cnblogs.com/face/536593/20130607120039.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3458598" class="layer">#2楼</a><a name="3458598" id="comment_anchor_3458598"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-25 11:18</span> <a id="a_comment_author_3458598" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3458598" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3458565" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3458565);">@</a>
biakia<br>感谢您的评论支持！您说的极是。这里的代码本身是用来交流学习的，功能上也很有限。说到分布式架构，能引入zookeeper进行服务治理，还可以有dubbo这样优秀的rpc框架可以借鉴。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3458598,&#39;Digg&#39;,this)">支持(1)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3458598,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3458598_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459213" class="layer">#3楼</a><a name="3459213" id="comment_anchor_3459213"></a>  <span class="comment_date">2016-06-27 10:00</span> <a id="a_comment_author_3459213" href="http://www.cnblogs.com/scy251147/" target="_blank">程序诗人</a> <a href="http://msg.cnblogs.com/send/%E7%A8%8B%E5%BA%8F%E8%AF%97%E4%BA%BA" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459213" class="blog_comment_body">mark，写的不错，正在学习。 和.net的 socketasynceventargs具有可比性没有？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459213,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459213,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459213_avatar" style="display:none;">http://pic.cnblogs.com/face/47012/20131031113822.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459238" class="layer">#4楼</a><a name="3459238" id="comment_anchor_3459238"></a>  <span class="comment_date">2016-06-27 10:23</span> <a id="a_comment_author_3459238" href="http://home.cnblogs.com/u/916671/" target="_blank">什麼江湖</a> <a href="http://msg.cnblogs.com/send/%E4%BB%80%E9%BA%BC%E6%B1%9F%E6%B9%96" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459238" class="blog_comment_body">能给个源码学习不？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459238,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459238,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459260" class="layer">#5楼</a><a name="3459260" id="comment_anchor_3459260"></a>  <span class="comment_date">2016-06-27 10:50</span> <a id="a_comment_author_3459260" href="http://www.cnblogs.com/qicosmos/" target="_blank">qicosmos(江南)</a> <a href="http://msg.cnblogs.com/send/qicosmos%28%E6%B1%9F%E5%8D%97%29" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459260" class="blog_comment_body">qps可以到多少？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459260,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459260,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459260_avatar" style="display:none;">http://pic.cnblogs.com/face/468725/20150512155458.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459340" class="layer">#6楼</a><a name="3459340" id="comment_anchor_3459340"></a>  <span class="comment_date">2016-06-27 12:05</span> <a id="a_comment_author_3459340" href="http://www.cnblogs.com/heros/" target="_blank">heros</a> <a href="http://msg.cnblogs.com/send/heros" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459340" class="blog_comment_body">netty做异步高并发非常不错。如果是产品中使用，可能还是会选thrift，可以跨语言，通信方式也可以自己定义。性能也高了许多。当然不差钱的企业可以用ice。<br>顶楼主的轮子。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459340,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459340,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459350" class="layer">#7楼</a><a name="3459350" id="comment_anchor_3459350"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 12:30</span> <a id="a_comment_author_3459350" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459350" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459213" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459213);">@</a>
程序诗人<br>抱歉，.NET方面的SocketAsyncEventArgs不太了解。有空学习一下！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459350,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459350,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459350_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459351" class="layer">#8楼</a><a name="3459351" id="comment_anchor_3459351"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 12:31</span> <a id="a_comment_author_3459351" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459351" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459238" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459238);">@</a>
什麼江湖<br>源码我已经全部贴出来了，你可以把它弄到本地，添加一下库的引用，差不多应该可以跑起来了！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459351,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459351,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459351_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459352" class="layer">#9楼</a><a name="3459352" id="comment_anchor_3459352"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 12:32</span> <a id="a_comment_author_3459352" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459352" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459260" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459260);">@</a>
qicosmos(江南)<br>具体没有验证过，暂时无法给出具体的数据！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459352,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459352,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459352_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459353" class="layer">#10楼</a><a name="3459353" id="comment_anchor_3459353"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 12:36</span> <a id="a_comment_author_3459353" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459353" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459340" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459340);">@</a>
heros<br>感谢您的点评！谢谢支持！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459353,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459353,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459353_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459447" class="layer">#11楼</a><a name="3459447" id="comment_anchor_3459447"></a>  <span class="comment_date">2016-06-27 14:57</span> <a id="a_comment_author_3459447" href="http://www.cnblogs.com/vbfool/" target="_blank">vbfool</a> <a href="http://msg.cnblogs.com/send/vbfool" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459447" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459213" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459213);">@</a>
程序诗人<br><fieldset class="comment_quote"><legend><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459213" title="查看引用原文">引用</a></legend>mark，写的不错，正在学习。 和.net的 socketasynceventargs具有可比性没有？</fieldset><br>Azure写了一个DotNetty，.NET版的Netty，就是使用了socketasynceventargs，算是一种封装。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459447,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459447,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459447_avatar" style="display:none;">http://pic.cnblogs.com/face/181045/20130802110703.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459588" class="layer">#12楼</a><a name="3459588" id="comment_anchor_3459588"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 17:35</span> <a id="a_comment_author_3459588" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459588" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459447" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459447);">@</a>
vbfool<br>感谢分享，我后面也了解一下。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459588,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459588,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459588_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459629" class="layer">#13楼</a><a name="3459629" id="comment_anchor_3459629"></a>  <span class="comment_date">2016-06-27 18:21</span> <a id="a_comment_author_3459629" href="http://www.cnblogs.com/Binhua-Liu/" target="_blank">Binhua Liu</a> <a href="http://msg.cnblogs.com/send/Binhua%20Liu" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459629" class="blog_comment_body">值得一读。<br>不过就像你说的<br>1，Java原生的序列化效率太低，可以尝试Protobuf<br>2，可以尝试无锁编程</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459629,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459629,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459629_avatar" style="display:none;">http://pic.cnblogs.com/face/134885/20160618231628.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3459695" class="layer">#14楼</a><a name="3459695" id="comment_anchor_3459695"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-06-27 21:37</span> <a id="a_comment_author_3459695" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3459695" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3459629" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3459629);">@</a>
Binhua Liu<br>感谢您的点评支持！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3459695,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3459695,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3459695_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3466291" class="layer">#15楼</a><a name="3466291" id="comment_anchor_3466291"></a>  <span class="comment_date">2016-07-08 12:45</span> <a id="a_comment_author_3466291" href="http://www.cnblogs.com/zzy0471/" target="_blank">会长</a> <a href="http://msg.cnblogs.com/send/%E4%BC%9A%E9%95%BF" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3466291" class="blog_comment_body">WCF算不算实现了Remote Procedure Call Protocol呢</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3466291,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3466291,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3466291_avatar" style="display:none;">http://pic.cnblogs.com/face/29548/20141125190340.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3467098" class="layer">#16楼</a><a name="3467098" id="comment_anchor_3467098"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-07-10 10:18</span> <a id="a_comment_author_3467098" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3467098" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3466291" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3466291);">@</a>
会长<br>RPC只是一种广义上的协议规范，WCF是SOA架构在.NET下的实现，它都支持跨语言域的服务请求调用，从这个角度来看，一定算是实现了RPC规范。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3467098,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3467098,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3467098_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3487804" class="layer">#17楼</a><a name="3487804" id="comment_anchor_3487804"></a>  <span class="comment_date">2016-08-11 21:05</span> <a id="a_comment_author_3487804" href="http://home.cnblogs.com/u/1007675/" target="_blank">superchenforever</a> <a href="http://msg.cnblogs.com/send/superchenforever" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3487804" class="blog_comment_body">您好，楼主，我看到您分享到github上面的工程，是不是两个工程合在一起了，我只想参考使用Netty开发实现高性能的RPC服务器这个工程的源代码，可否明确一下，谢谢。而且看下载的core里面，并没有上面的RpcServerStart.java代码。并且好多地方引用的jar包也跟文章中的不一样。可否只是提交一下，这个文章中的工程源代码。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3487804,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3487804,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3488162" class="layer">#18楼</a><a name="3488162" id="comment_anchor_3488162"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-08-12 12:54</span> <a id="a_comment_author_3488162" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3488162" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3487804" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3487804);">@</a>
superchenforever<br>感谢您的关注，其实github的NettyRPC工程里面，协议类型为JDKSERIALIZE的情况，就是本文中说到的Java原生序列化方式，我把两篇文章主要的设计实现合并到一起了，对应的入口为：NettyRPC/src/newlandframework/netty/rpc/core/RpcServerJdkNativeProtocolStarter.java，您可以看下。不过生产运行情况下，不太建议用这种方式进行消息对象的序列化，性能不太高。如果是学习研究，那可以看看！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3488162,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3488162,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3488162_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3489491" class="layer">#19楼</a><a name="3489491" id="comment_anchor_3489491"></a>  <span class="comment_date">2016-08-15 11:43</span> <a id="a_comment_author_3489491" href="http://home.cnblogs.com/u/1007675/" target="_blank">superchenforever</a> <a href="http://msg.cnblogs.com/send/superchenforever" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3489491" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3488162" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3488162);">@</a>
Newland<br>您好楼主，现在要用netty做一个对接梦网短信平台的发送接口，有些问题想详细请教您，可否加一下鄙人的qq：1198133591，不胜感激。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3489491,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3489491,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3492411" class="layer">#20楼</a><a name="3492411" id="comment_anchor_3492411"></a>  <span class="comment_date">2016-08-19 14:58</span> <a id="a_comment_author_3492411" href="http://home.cnblogs.com/u/989893/" target="_blank">NOTHING604</a> <a href="http://msg.cnblogs.com/send/NOTHING604" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3492411" class="blog_comment_body">感谢楼主的博客，分析了一遍代码，学到很多知识，加深了对netty的认识。特别是这一点处理：<br>“3、Netty的IO处理线程池，如果遇到非常耗时的业务，出现阻塞了咋办？这样不是很容易把后端的NIO线程给挂死、阻塞？本文的处理方式是，对于复杂的后端业务，分派到专门的业务线程池里面，进行异步回调处理。”<br>之前使用netty过程中就是因为业务线程耗时导致后端的NIO线程挂死，阻塞，看了楼主博客有了解决方案。感谢。。。。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3492411,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3492411,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3493198" class="layer">#21楼</a><a name="3493198" id="comment_anchor_3493198"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-08-20 23:33</span> <a id="a_comment_author_3493198" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3493198" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3492411" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3492411);">@</a>
NOTHING604<br>感谢您的支持和关注！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3493198,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3493198,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3493198_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3494181" class="layer">#22楼</a><a name="3494181" id="comment_anchor_3494181"></a>  <span class="comment_date">2016-08-22 21:15</span> <a id="a_comment_author_3494181" href="http://home.cnblogs.com/u/1013153/" target="_blank">sqskg</a> <a href="http://msg.cnblogs.com/send/sqskg" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3494181" class="blog_comment_body">你好，我想问一下工程依赖到了哪些个jar包</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3494181,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3494181,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3494233" class="layer">#23楼</a><a name="3494233" id="comment_anchor_3494233"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-08-22 22:59</span> <a id="a_comment_author_3494233" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3494233" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3494181" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3494181);">@</a>
sqskg<br>请参考：<a href="https://github.com/tang-jie/NettyRPC/blob/master/project.properties" target="_blank">https://github.com/tang-jie/NettyRPC/blob/master/project.properties</a></div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3494233,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3494233,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3494233_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3519992" class="layer">#24楼</a><a name="3519992" id="comment_anchor_3519992"></a>  <span class="comment_date">2016-09-26 20:50</span> <a id="a_comment_author_3519992" href="http://home.cnblogs.com/u/1033471/" target="_blank">fwvv</a> <a href="http://msg.cnblogs.com/send/fwvv" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3519992" class="blog_comment_body">感谢楼主的轮子，特意为了顶贴注册的！rpc里面的Proxy很妙，赞一个</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3519992,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3519992,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3521897" class="layer">#25楼</a><a name="3521897" id="comment_anchor_3521897"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-09-28 22:13</span> <a id="a_comment_author_3521897" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3521897" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3519992" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3519992);">@</a>
fwvv<br>过奖了，感谢您的支持和关注！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3521897,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3521897,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3521897_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3523700" class="layer">#26楼</a><a name="3523700" id="comment_anchor_3523700"></a>  <span class="comment_date">2016-10-02 11:01</span> <a id="a_comment_author_3523700" href="http://www.cnblogs.com/freedommovie/" target="_blank">杉枫</a> <a href="http://msg.cnblogs.com/send/%E6%9D%89%E6%9E%AB" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3523700" class="blog_comment_body">很赞，思路扩展一下可以作为真正的rpc框架了</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3523700,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3523700,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3523700_avatar" style="display:none;">http://pic.cnblogs.com/face/942404/20160810174243.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3523796" class="layer">#27楼</a><a name="3523796" id="comment_anchor_3523796"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-10-02 21:28</span> <a id="a_comment_author_3523796" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3523796" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3523700" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3523700);">@</a>
自由的枫林<br>感谢您支持关注！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3523796,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3523796,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3523796_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3528929" class="layer">#28楼</a><a name="3528929" id="comment_anchor_3528929"></a>  <span class="comment_date">2016-10-12 11:34</span> <a id="a_comment_author_3528929" href="http://www.cnblogs.com/andyboy/" target="_blank">尹剑平</a> <a href="http://msg.cnblogs.com/send/%E5%B0%B9%E5%89%91%E5%B9%B3" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3528929" class="blog_comment_body">很赞，最近在学习NIO相关的东西，这篇博客正解决了我苦于不知道该如何实践NIO理论知识的苦恼，真的很赞</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3528929,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3528929,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3528929_avatar" style="display:none;">http://pic.cnblogs.com/face/507865/20130731091600.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3528993" class="layer">#29楼</a><a name="3528993" id="comment_anchor_3528993"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-10-12 12:43</span> <a id="a_comment_author_3528993" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3528993" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3528929" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3528929);">@</a>
尹剑平<br>感谢您的关注！最近重构了NettyRPC，新增了很多功能。推出NettyRPC 2.0版本，托管在github上面，有兴趣的话可以关注一下：<a href="https://github.com/tang-jie/NettyRPC" target="_blank">https://github.com/tang-jie/NettyRPC</a></div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3528993,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3528993,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3528993_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3539890" class="layer">#30楼</a><a name="3539890" id="comment_anchor_3539890"></a>  <span class="comment_date">2016-10-24 21:00</span> <a id="a_comment_author_3539890" href="http://home.cnblogs.com/u/1048948/" target="_blank">大风少</a> <a href="http://msg.cnblogs.com/send/%E5%A4%A7%E9%A3%8E%E5%B0%91" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3539890" class="blog_comment_body">机器什么配置，一万次调用11秒 时间算很长了吧</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3539890,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3539890,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3540045" class="layer">#31楼</a><a name="3540045" id="comment_anchor_3540045"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-10-25 09:31</span> <a id="a_comment_author_3540045" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3540045" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3539890" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3539890);">@</a>
大风少<br>本文是基于JDK原生的对象序列化（ObjectOutputStream/ObjectInputStream），后续有引入了kryo、hessian、protostuff，性能有所提升。有一篇文章简单、粗略地测试了一下kryo、hessian、JDK原生的对象序列化之间的性能比较：<a href="http://www.cnblogs.com/jietang/p/5675171.html" target="_blank">http://www.cnblogs.com/jietang/p/5675171.html</a></div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3540045,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3540045,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3540045_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3543802" class="layer">#32楼</a><a name="3543802" id="comment_anchor_3543802"></a>  <span class="comment_date">2016-10-29 17:11</span> <a id="a_comment_author_3543802" href="http://home.cnblogs.com/u/1048948/" target="_blank">大风少</a> <a href="http://msg.cnblogs.com/send/%E5%A4%A7%E9%A3%8E%E5%B0%91" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3543802" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3540045" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3540045);">@</a>
Newland<br><fieldset class="comment_quote"><legend><a href="http://www.cnblogs.com/jietang/p/5615681.html#3540045" title="查看引用原文">引用</a></legend>@<br>大风少<br>本文是基于JDK原生的对象序列化（ObjectOutputStream/ObjectInputStream），后续有引入了kryo、hessian、protostuff，性能有所提升。有一篇文章简单、粗略地测试了一下kryo、hessian、JDK原生的对象序列化之间的性能比较：http://www.cnblogs.com/jietang/p/5675171.html</fieldset><br><br>通过测试nettrpc2.0用protostuff协议，10000次加乘操作在5秒左右，5000次调用均在1秒内完成。开始是我理解有问题，现在发现测试的是10000并发，能达到这样的速度已经很不错了。我打算在生产环境用这个框架，到时候碰到问题还请大神多多指教。测试的时候发现一个bug，kryo序列化需要提前注册class，这样代码侵入太强，有没有好的解决方法？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3543802,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3543802,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3545105" class="layer">#33楼</a><a name="3545105" id="comment_anchor_3545105"></a>[<span class="louzhu">楼主</span>]  <span class="comment_date">2016-10-31 22:32</span> <a id="a_comment_author_3545105" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3545105" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3543802" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3543802);">@</a>
大风少<br>不敢当啊。回答一下你的问题。<br>kryo如果类事先注册了，就可以使用writeObject、readObject。<br>如果不先注册，写对象的同时也会注册，并且只能用writeClassAndObject和readClassAndObject读写对象。<br>可以看下：<a href="https://github.com/EsotericSoftware/kryo" target="_blank">https://github.com/EsotericSoftware/kryo</a> 中Reading and writing章节的说明。<br>至于你说的提前类注册，导致框架侵入性太强的问题，是不是可以考虑利用spring ioc注入到一个对象容器里面来进行规避？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3545105,&#39;Digg&#39;,this)">支持(1)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3545105,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3545105_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3557918" class="layer">#34楼</a><a name="3557918" id="comment_anchor_3557918"></a>  <span class="comment_date">2016-11-17 01:10</span> <a id="a_comment_author_3557918" href="http://www.cnblogs.com/andot/" target="_blank">香辣教师</a> <a href="http://msg.cnblogs.com/send/%E9%A6%99%E8%BE%A3%E6%95%99%E5%B8%88" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3557918" class="blog_comment_body">写的很详细。不过有一点说的不是很准确。一个RPC是否跨语言跟是否使用IDL关系不大，很多不跨语言的RPC也会使用IDL来生成框架代码。而也有不使用IDL就能实现跨语言功能的RPC，比如最著名的Hprose就是一个不需要IDL的跨语言跨平台的动态RPC，支持的语言比那些使用IDL的静态RPC还要多，而且性能还超好，甚至连浏览器和hybird APP里面的javascript都支持，还带跨域功能支持。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3557918,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3557918,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jietang/p/5615681.html#3558899" class="layer">#35楼</a><a name="3558899" id="comment_anchor_3558899"></a>[<span class="louzhu">楼主</span>]<span id="comment-maxId" style="display:none;">3558899</span><span id="comment-maxDate" style="display:none;">2016/11/17 22:25:23</span>  <span class="comment_date">2016-11-17 22:25</span> <a id="a_comment_author_3558899" href="http://www.cnblogs.com/jietang/" target="_blank">Newland</a> <a href="http://msg.cnblogs.com/send/Newland" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3558899" class="blog_comment_body"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3557918" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3557918);">@</a>
香辣教师<br>感谢批评指正，互相学习了！</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3558899,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3558899,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3558899_avatar" style="display:none;">http://pic.cnblogs.com/face/913759/20160320160025.png</span>
			</div>
		</div>
	<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="http://www.cnblogs.com/jietang/p/5615681.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/jietang/p/5615681.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank">【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br><a href="http://vcloud.163.com/?adchannel=bp_cnblogs2" target="_blank">【推荐】用1%的研发投入，搭载3倍性能的网易视频云技术</a><br><a href="http://rongcloud.cn/reports/journal2" target="_blank">【推荐】融云发布 App 社交化白皮书 IM 提升活跃超 8 倍</a><br></div>
<div id="opt_under_post"></div>
<div id="ad_c1" class="c_ad_block"><a href="http://www.gcpowertools.com.cn/products/activereports_overview.htm?utm_source=cnblogs&amp;utm_medium=blogpage&amp;utm_term=bottom&amp;utm_content=AR&amp;utm_campaign=community" target="_blank"><img width="300" height="250" src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/24442-20161115165230123-1587531896.png" alt=""></a></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="http://news.cnblogs.com/n/557674/" target="_blank">微软也要做自己的“Touch Bar”? 新专利竟是个中文输入神器</a><br> ·  <a href="http://news.cnblogs.com/n/557673/" target="_blank">5分钟回顾Linux 25年的发展历程与变迁</a><br> ·  <a href="http://news.cnblogs.com/n/557672/" target="_blank">Visual Studio Code 1.7.2发布</a><br> ·  <a href="http://news.cnblogs.com/n/557671/" target="_blank">恶意视频链接会导致任何iOS设备死机</a><br> ·  <a href="http://news.cnblogs.com/n/557670/" target="_blank">如何把女儿培养成萌萌哒萝莉程序员</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="ad_c2" class="c_ad_block"><a href="https://www.jiguang.cn/devservice/?from=cnblogs01" target="_blank"><img width="468" height="60" src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/24442-20161114133622451-1554357151.jpg" alt=""></a></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/555750/" target="_blank">循序渐进地代码重构</a><br> ·  <a href="http://kb.cnblogs.com/page/554496/" target="_blank">技术的正宗与野路子</a><br> ·  <a href="http://kb.cnblogs.com/page/553682/" target="_blank">陈皓：什么是工程师文化？</a><br> ·  <a href="http://kb.cnblogs.com/page/551422/" target="_blank">没那么难，谈CSS的设计模式</a><br> ·  <a href="http://kb.cnblogs.com/page/550625/" target="_blank">程序猿媳妇儿注意事项</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/tangjie.bmp" height="290" width="290"><br>
<b>博主简介：</b>80后程序员，擅长Java/C++服务端程序设计开发，现工作生活于福州，业余时间喜欢看书、品茗，并乐此不疲。<br>
<b>我的开源项目github地址：</b><br>
<a href="https://github.com/tang-jie" target="_blank"><img src="./谈谈如何使用Netty开发实现高性能的RPC服务器 - Newland - 博客园_files/tangjie-git.gif" height="70" width="230"></a><div id="profile_block">昵称：<a href="http://home.cnblogs.com/u/jietang/">Newland</a><br>园龄：<a href="http://home.cnblogs.com/u/jietang/" title="入园时间：2016-03-15">8个月</a><br>荣誉：<a href="http://www.cnblogs.com/expert/">推荐博客</a><br>粉丝：<a href="http://home.cnblogs.com/u/jietang/followers/">91</a><br>关注：<a href="http://home.cnblogs.com/u/jietang/followees/">1</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;1850cabf-69ea-e511-9fc1-ac853d9f53cc&#39;)">+加关注</a></div></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="日历">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2016/10/01&#39;);return false;">&lt;</a></td><td align="center">2016年11月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2016/12/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td class="CalWeekendDay" align="center">5</td></tr><tr><td class="CalWeekendDay" align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td align="center">11</td><td class="CalWeekendDay" align="center">12</td></tr><tr><td class="CalWeekendDay" align="center">13</td><td align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td class="CalWeekendDay" align="center">19</td></tr><tr><td class="CalWeekendDay" align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalTodayDay" align="center">23</td><td align="center">24</td><td align="center">25</td><td class="CalWeekendDay" align="center">26</td></tr><tr><td class="CalWeekendDay" align="center">27</td><td align="center">28</td><td align="center">29</td><td align="center">30</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<div class="catListLink">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/jietang/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="http://www.cnblogs.com/jietang/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="http://www.cnblogs.com/jietang/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="http://www.cnblogs.com/jietang/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="http://www.cnblogs.com/jietang/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div></div><div id="sidebar_toptags" class="sidebar-block">
<div class="catListTag">
<h3 class="catListTitle">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/jietang/tag/Java/">Java</a>(8)</li><li><a href="http://www.cnblogs.com/jietang/tag/Netty/">Netty</a>(2)</li>
</ul>
</div></div><div id="sidebar_categories">
<div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
<h3 class="catListTitle">随笔档案</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/jietang/archive/2016/10.html">2016年10月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/jietang/archive/2016/09.html">2016年9月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/jietang/archive/2016/08.html">2016年8月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/jietang/archive/2016/07.html">2016年7月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/jietang/archive/2016/06.html">2016年6月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/jietang/archive/2016/05.html">2016年5月 (1)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/jietang/archive/2016/04.html">2016年4月 (2)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/jietang/archive/2016/03.html">2016年3月 (2)</a> </li>

</ul>

</div>

<div id="sidebar_links804240" class="catList sidebar-block">
<h3 class="catListTitle">软件技术博客链接</h3>

<ul>

<li><a id="CatList_LinkList_1_Link_0" href="http://www.cnblogs.com/chuyongliu" rel="nofollow" target="_blank">刘楚勇</a> </li>

</ul>

</div>

</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3558899">1. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@香辣教师感谢批评指正，互相学习了！...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3557918">2. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">写的很详细。不过有一点说的不是很准确。一个RPC是否跨语言跟是否使用IDL关系不大，很多不跨语言的RPC也会使用IDL来生成框架代码。而也有不使用IDL就能实现跨语言功能的RPC，比如最著名的Hpro......</li>
        <li class="recent_comment_author">--香辣教师</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3545105">3. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@大风少不敢当啊。回答一下你的问题。kryo如果类事先注册了，就可以使用writeObject、readObject。如果不先注册，写对象的同时也会注册，并且只能用writeClassAndObjec......</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3543802">4. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@Newland引用@大风少本文是基于JDK原生的对象序列化（ObjectOutputStream/ObjectInputStream），后续有引入了kryo、hessian、protostuff，性......</li>
        <li class="recent_comment_author">--大风少</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3540045">5. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@大风少本文是基于JDK原生的对象序列化（ObjectOutputStream/ObjectInputStream），后续有引入了kryo、hessian、protostuff，性能有所提升。有一篇文......</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3539890">6. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">机器什么配置，一万次调用11秒 时间算很长了吧</li>
        <li class="recent_comment_author">--大风少</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5983038.html#3537546">7. Re:基于Netty打造RPC服务器设计经验谈</a></li>
        <li class="recent_comment_body">@千年风雅丶感谢您的支持！后续有时间会考虑推出C++服务端的应用开发系列文章！...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5983038.html#3537431">8. Re:基于Netty打造RPC服务器设计经验谈</a></li>
        <li class="recent_comment_body">支持，希望前辈能再分享一些C++服务器端方面的经验。感谢分享~</li>
        <li class="recent_comment_author">--千年风雅丶</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3528993">9. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@尹剑平感谢您的关注！最近重构了NettyRPC，新增了很多功能。推出NettyRPC 2.0版本，托管在github上面，有兴趣的话可以关注一下：...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3528929">10. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">很赞，最近在学习NIO相关的东西，这篇博客正解决了我苦于不知道该如何实践NIO理论知识的苦恼，真的很赞</li>
        <li class="recent_comment_author">--尹剑平</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3523796">11. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@自由的枫林感谢您支持关注！...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3523700">12. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">很赞，思路扩展一下可以作为真正的rpc框架了</li>
        <li class="recent_comment_author">--自由的枫林</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3521897">13. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">@fwvv过奖了，感谢您的支持和关注！...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5615681.html#3519992">14. Re:谈谈如何使用Netty开发实现高性能的RPC服务器</a></li>
        <li class="recent_comment_body">感谢楼主的轮子，特意为了顶贴注册的！rpc里面的Proxy很妙，赞一个</li>
        <li class="recent_comment_author">--fwvv</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5847458.html#3513768">15. Re:Netty构建分布式消息队列实现原理浅析</a></li>
        <li class="recent_comment_body">@呵呵呵暗暗Netty UDP本人的实战经验较少，不好给出什么经验，不过建议你看下李林锋写的《Netty权威指南》里面UDP协议开发章节。热点方法是用JDK自带的VisualVM。最后，谢谢您的支持、......</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5847458.html#3513453">16. Re:Netty构建分布式消息队列实现原理浅析</a></li>
        <li class="recent_comment_body">支持！请问下作者有用过netty udp方面的经验么 还有请问下热点方法下面的图是啥工具？</li>
        <li class="recent_comment_author">--呵呵呵暗暗</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5808735.html#3506008">17. Re:Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇</a></li>
        <li class="recent_comment_body">@阿凡卢谢谢点评关注！目前的分布式只针对生产者Producer、消费者Consumer的，其中Broker是单点，暂不支持集群模式。后续有时间会考虑增强。...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5808735.html#3505964">18. Re:Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇</a></li>
        <li class="recent_comment_body">zeromq好像是没有broker的。<br>你的AvatarMQ的broker是分布式多节点的吗？否则怎么体现分布式？</li>
        <li class="recent_comment_author">--阿凡卢</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5675171.html#3505242">19. Re:Netty实现高性能RPC服务器优化篇之消息序列化</a></li>
        <li class="recent_comment_body">@Tualatin谢谢您的建议，后续会把messagepack、protostuff集成到NettyRPC编解码里面。...</li>
        <li class="recent_comment_author">--Newland</li>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/jietang/p/5675171.html#3504910">20. Re:Netty实现高性能RPC服务器优化篇之消息序列化</a></li>
        <li class="recent_comment_body">相比Kryo、Hessian、Java本地序列化;MsgPack、Protostuff可能更有优势，</li>
        <li class="recent_comment_author">--Tualatin</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="http://www.cnblogs.com/jietang/p/5615681.html">1. 谈谈如何使用Netty开发实现高性能的RPC服务器(6798)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5353220.html">2. 异步并行批处理框架设计的一些思考(5407)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5321841.html">3. 业务规则引擎浅析(3742)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5423438.html">4. Storm构建分布式实时处理应用初探(2044)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5675171.html">5. Netty实现高性能RPC服务器优化篇之消息序列化(1681)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5808735.html">6. Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇(1367)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5847458.html">7. Netty构建分布式消息队列实现原理浅析(1312)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5983038.html">8. 基于Netty打造RPC服务器设计经验谈(1010)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5506373.html">9. 动手打造自己的跨语言异构模块通信解决方案(825)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5298985.html">10. 业务事件模型的实现(361)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock"><ul><li><a href="http://www.cnblogs.com/jietang/p/5615681.html">1. 谈谈如何使用Netty开发实现高性能的RPC服务器(35)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5675171.html">2. Netty实现高性能RPC服务器优化篇之消息序列化(9)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5353220.html">3. 异步并行批处理框架设计的一些思考(8)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5423438.html">4. Storm构建分布式实时处理应用初探(5)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5808735.html">5. Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇(4)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5321841.html">6. 业务规则引擎浅析(2)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5847458.html">7. Netty构建分布式消息队列实现原理浅析(2)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5983038.html">8. 基于Netty打造RPC服务器设计经验谈(2)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5506373.html">9. 动手打造自己的跨语言异构模块通信解决方案(2)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">推荐排行榜</h3>
<div id="TopDiggPostsBlock"><ul><li><a href="http://www.cnblogs.com/jietang/p/5615681.html">1. 谈谈如何使用Netty开发实现高性能的RPC服务器(23)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5353220.html">2. 异步并行批处理框架设计的一些思考(12)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5423438.html">3. Storm构建分布式实时处理应用初探(11)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5983038.html">4. 基于Netty打造RPC服务器设计经验谈(8)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5808735.html">5. Netty构建分布式消息队列（AvatarMQ）设计指南之架构篇(5)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5675171.html">6. Netty实现高性能RPC服务器优化篇之消息序列化(4)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5321841.html">7. 业务规则引擎浅析(4)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5847458.html">8. Netty构建分布式消息队列实现原理浅析(3)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5506373.html">9. 动手打造自己的跨语言异构模块通信解决方案(3)</a></li><li><a href="http://www.cnblogs.com/jietang/p/5298985.html">10. 业务事件模型的实现(1)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2016 Newland
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


</body></html>